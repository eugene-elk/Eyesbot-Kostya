#pragma config(Sensor, S4,     MSDIST,         sensorI2CCustomFastSkipStates9V)
#pragma config(Motor,  motorA,          mA,            tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mB,            tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mC,            tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/mindsensors-irdist.h"

int posA = 0, posB = 0, posC = 0;

int waiting = 200;
int waitingBig = 800;

int sum1 = 150, sum1_t = 150;
int sum1_arr[30];

const int count_of_measures = 30;

void setPos(int a, int b, int c, int t = 0) {
	posA = a;
	posB = b;
	posC = c;
	if (t > 0) wait1Msec(t);
}

void setPosSlowly(int finishPosA, int finishPosB, int finishPosC, int parts = 20, int ms = 50)
{
	int startPosA = nMotorEncoder[mA];
	int startPosB = nMotorEncoder[mB];
	int startPosC = nMotorEncoder[mC];

	int diffA = finishPosA - startPosA;
	int diffB = finishPosB - startPosB;
	int diffC = finishPosC - startPosC;

	float divided_diffA = (float) diffA / parts;
	float divided_diffB = (float) diffB / parts;
	float divided_diffC = (float) diffC / parts;

	for (int i = 1; i <= parts; i++) {
		setPos(startPosA + i*divided_diffA, startPosB + i*divided_diffB, startPosC + i*divided_diffC);
		wait1Msec(ms);
	}

	setPos(finishPosA, finishPosB, finishPosC);
	wait1Msec(ms);
}



task preg()
{
	float kA, kB, kC;

	while(true)
	{
		int errA = posA - nMotorEncoder[mA];
		int errB = posB - nMotorEncoder[mB];
		int errC = posC - nMotorEncoder[mC];

		if (errA < 0) kA = 0.6;
		else kA = 1.2;
		if (errB < 0) kB = 0.6;
		else kB = 1.2;
		if (errC < 0) kC = 0.6;
		else kC = 1.2;

		int uA = errA * kA;
		int uB = errB * kB;
		int uC = errC * kC;

		motor[mA] = uA;
		motor[mB] = uB;
		motor[mC] = uC;

		wait1Msec(10);
	}
}

void to_start() {
	motor[mA] = -15;
	motor[mB] = -15;
	motor[mC] = -15;
	wait1Msec(3000);
	motor[mA] = 0;
	motor[mB] = 0;
	motor[mC] = 0;
}

void jump() {
	setPos(220, 220, 220);
	wait1Msec(200);
}

void to_top() {
	setPos(350, 350, 350);
}

void closed() {
	setPos(10, 10, 10);
	wait1Msec(200);
}

void eyes_show() {
	setPosSlowly(380, 380, 10, 20, 200);
	wait1Msec(1000);
	setPosSlowly(380, 330, 10, 20, 200);
	wait1Msec(2000);
	setPosSlowly(380, 380, 10, 20, 200);
	wait1Msec(2000);
	setPosSlowly(330, 380, 10, 20, 200);
	wait1Msec(2000);
	setPosSlowly(380, 380, 10, 20, 200);
	wait1Msec(2000);
	setPosSlowly(330, 330, 10, 20, 200);
	wait1Msec(2000);
	setPosSlowly(350, 350, 350);
}

task sensor()
{

	while(true)
	{
		for (int i = 0; i < count_of_measures - 1; i++)
		{
			sum1_arr[i] = sum1_arr[i+1];
		}
		sum1_arr[count_of_measures - 1] = abs(MSDISTreadDist(MSDIST)) / 10;

		sum1_t = 0;
		for (int i = 0; i < count_of_measures; i++)
		{
			sum1_t += sum1_arr[i];
		}
		sum1_t /= count_of_measures;
		sum1 = sum1_t;

		if (sum1 < 40) PlaySound(soundBlip);

		wait1Msec(10);
	}
}

void zero_array()
{
	for(int i = 0; i < 30; i++)
	{
		sum1_arr[i] = 150;
	}
	sum1 = 150;
}

#include "flex_samples.c"

task main()
{
	srand(nSysTime);
	to_start();

	nMotorEncoder[mA] = 0;
	nMotorEncoder[mB] = 0;
	nMotorEncoder[mC] = 0;

	StartTask(preg);
	to_top();
	wait1Msec(2000);

	zero_array();
	StartTask(sensor);

	to_top();
	ClearMessage();
	ubyte input[3];

	while(true)
	{
		// while(abs(sum1) > 40)
		while(true)
		{
			nxtDisplayBigTextLine(2, "dist: %d", sum1);
			input[0] = 0;
			if(cCmdMessageGetSize(mailbox1) != 0) {
				cCmdMessageRead(input, 3, mailbox1);
				ClearMessage();
			}

			int to_flex = (int)input[0];
			int position = (int)input[1];
			int show = (int)input[2];

			nxtDisplayBigTextLine(4, "pos: %d", position);

			// position
			if (position == 1)
			{
				if (to_flex == 1)
					jump();
				else
					to_top();
			}
			else
			{
				closed();
			}

			// eyes show
			if (show == 1)
			{
				eyes_show();
			}
			wait1Msec(10);
		}

		if (input[1] == 1)
		{
			to_top();
			wait1Msec(300);
			int side = abs(rand()) % 4;
			switch(side)
			{
			case 0:
				setPos(300, 300, 120);
				break;
			case 1:
				setPos(300, 120, 300);
				break;
			case 2:
				setPos(120, 300, 300);
				break;
			default:
				setPos(440, 440, 440);
				break;
			}
			wait1Msec(1000);
		}
	}
}
